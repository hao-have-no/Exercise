<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>事件代理</title>
</head>
<body>
<div class="box">
    1234
    <div class="item">123</div>
</div>

<script>
    //1.filter
    // var arr= [1,10,20,30]
    // var brr = arr.filter((item)=>{
    //     return item>10;
    // },this)
    // console.log(arr);
    // console.log(brr);

    //2.splice(破坏原有数组),slice（不改变原有数组），substring（字符串截取）
    //let testArr=[1,2,3,4,5,6]
    // console.log(testArr,testArr.splice(2,2));
    // console.log(testArr,testArr.splice(4,1));

    // let newArr=testArr.slice(1);
    // let newArr2=testArr.slice(2,4);
    // console.log(testArr,newArr);
    // console.log(testArr,newArr2);
    // let str='12345678';
    // console.log(str,str.substring(2))
    // console.log(str,str.substring(2,6))


    //3.map,filter
    // var arr=[4,2,3,4]
    // for (i of arr){
    //     console.log(i);
    // }
    // var barr=arr.filter(i=>{
    //     return i>3
    // })
    // console.log(barr);

   //4阻止冒泡,及事件委托
   //  document.querySelector(".box").addEventListener("click",function () {
   //      console.log("123")
   //  })
   //  document.querySelector(".item").addEventListener("click",function (e) {
   //      console.log("456")
   //      e.stopPropagation();
   //  })

    //5.标准事件流及事件委托--eventTarget

    //6.this指向性问题
    // function Foo(){
    //       getName=function(){
    //         console.log(1)
    //     }
    //     return this;
    // }
    // var getName;
    // function getName(){
    //     console.log(5)
    // }
    // Foo.getName=function(){console.log(2)};
    // Foo.prototype.getName=function(){console.log(3)}
    // getName=function(){console.log(4)}
    //
    //
    // Foo.getName();
    // getName();//4
    // Foo().getName();//1
    // getName();
    // new Foo.getName();
    // new Foo().getName();//(new Foo).getName()=foo.getName(),只有实例化才能调用原型链上的方法，否则只能搜索作用域
    //  new new Foo().getName();//new(new Foo).getName=>new (foo).getName


    // function test(){
    //     getName=function(){
    //        console.log("1");
    //     }
    //     console.log("this"+this);
    //     return this;
    //
    // }
    // var getName=function(){
    //     console.log("2")
    // }
    //
    // getName();
    // test().getName();//==>var getName;getName=function(alert(1))
    // getName();

    // 7.对象的深浅拷贝（该方法无法实现对象的深拷贝）
    // function copyArray(arr){
    //     return arr.map((e)=>{
    //         if(typeof e === 'object'){
    //             return Object.assign({},e);
    //         }else{
    //             return e;
    //         }
    //     })
    // }
    // const arr=[1,2,3,{sss:"123"},5,6]
    // // const newarr=copyArray(arr);
    // const newarr=arr;
    // newarr.push("123");
    //
    // console.log(arr);
    // console.log(newarr);


    //8.函数的调用方式,结合作用域，this指向
    // var age = 38;
    // var obj = {
    //     age: 18,
    //     getAge: function() {
    //          function foo() {
    //             console.log(this.age); // 这里的this属于函数 foo；   打印 38
    //         }
    //         foo()//实际是window调用，this指向全局作用域
    //         // console.log(this.age)
    //     },
    //     foos:function(){
    //         console.log(this.age);
    //     }
    // };
    // obj.getAge();



    // 9.
    // 防抖
    // var timer=false;
    //
    // function bindfang() {
    //         clearTimeout(timer);
    //
    //         timer=setTimeout(function(){
    //             console.log("123");
    //         },300)
    // }
    //
    //
    // //节流
    // var mark=true;
    //
    // function debugd(){
    // if(!mark){
    //     return
    // }
    // mark =false;
    // setTimeout(function(){
    //   console.log("111");
    //   mark=true;
    // },time)
    // }


    //递归进行深拷贝
    // var oldarr=[1,2,3,{"ss":123},5,6];
    //通过json和javascript值（或者对象），来改变数据对应的堆区间
    // var clonearr=JSON.parse(JSON.stringify(oldarr));
    //
    // clonearr.push("12345");
    // clonearr[3].obj="12345";
    //
    // console.log(oldarr,clonearr);

    // function deepclone(obj){
    //     const clonedeep=obj.constructor === Array?[]:{};
    //
    //     for (let item in obj){
    //         if (obj.hasOwnProperty(item)){
    //             if (obj[item]&&typeof obj[item] === 'object'){
    //                 clonedeep[item] = obj[item].constructor === Array?[]:{};
    //                 clonedeep[item] = deepclone(obj[item]);
    //             }else{
    //                 clonedeep[item]=obj[item];
    //             }
    //         }
    //     }
    //     return clonedeep;
    // }
    //
    // var clonearr=deepclone(oldarr);
    // clonearr.push("12345");
    // clonearr[3].obj="12345";
    //
    // console.log(oldarr,clonearr);


    //闭包的使用--js模块封装方法(面向对象的私有变量成员)
    // function Ptest(pwd){
    //     var password=pwd
    //
    //     function getPassword() {
    //      return password;
    //     }
    //
    //     this.getPwdSwevice=function () {
    //         return getPassword();
    //     }
    //
    //     Ptest.prototype.checkPwd=function (pwd) {
    //         return this.getPwdSwevice() === pwd;
    //     }
    // }
    //
    // var tp=new Ptest("1111");
    // console.log(tp.checkPwd("1111"));
    // console.log(tp.password);
    // console.log(tp.getPwdSwevice())
    // console.log(tp.getPassword);

    // function deleteArr(){
    //     var arr=[1,2,3,4,5,6,7,8];
    //    for (let i=0;i<arr.length;i++){
    //        if (arr[i]%2 != 0){
    //            arr.splice(i,1);
    //            i--;
    //        }
    //    }
    //    console.log(arr);
    // }
    //
    // deleteArr()


    // function accum(obj){
    //     // var obj = obj;
    //     var str = "";
    //     for(var i = 0;i<obj.length;i++){
    //         var curr_letters = obj.substr(i,1);          //获取当前字母
    //         var curr_str = curr_letters.toUpperCase();   //第一个字母转大写
    //         for(var j = i;j>0;j--){                   //循环在后面添加小写字母
    //             curr_str += curr_letters.toUpperCase();
    //         }
    //         if(i != obj.length-1){//不为最后一个字母添加分割符
    //             curr_str += "-";
    //         }
    //         str += curr_str
    //     }
    //     return str;
    // }
    // console.log(accum("abcde"));




    //函数柯里化
    // function calls(a){
    //     var sum=a;
    //
    //     function adds(b) {
    //         sum += b;
    //         return adds;
    //     }
    //
    //     adds.toString=function () {
    //         return sum;
    //     }
    //
    //     return adds;
    // }
    //
    // console.log(calls(1)(2)(3).toString());


    // function accum(obj){
    //     var str="";
    //     for (let i=0;i<obj.length;i++){
    //         var cur=obj.substr(i,1);
    //         var cur_letter=cur.toUpperCase();
    //         for (var j=i;j>0;j++){
    //             cur_letter +=cur_letter;
    //         }
    //         if (i !=obj.length-1){
    //             cur_letter+="-";
    //         }
    //         str +=cur_letter;
    //     }
    //     return str;
    // }
    // console.log(accum("abcde"));

        const col1= function () {
            var p=new Promise(function (resolve,reject) {
                resolve(1);
            });
            return p;
    }
    const col2=function () {
        var p=new Promise(function (resolve,reject) {
            resolve(2);
        });
        return p;
    }
    const col3=function () {
        var p=new Promise(function (resolve,reject) {
            resolve(3);
        });
        return p;
    }

    Promise.all([col1(),col2(), col3()]).then(
        function (result) {
            // return posts;

                // var sum = 0;
                // result.forEach(function(val,index,arr){
                //     sum += val;
                // })
                // console.log(sum);
            result.reduce(function (prev,cur) {
                return prev+cur;
            })

        }
     ).catch(function(){

        }
    );
</script>
</body>
</html>
