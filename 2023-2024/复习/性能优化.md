## 性能优化-前端页面秒开方案

### 从几个面展开说说-系统性总结
+ 页面加载链路分类
+ 资源性能分类
+ 协作分类
+ 优化分类

### 深度回答->页面加载链路+流程优化+协作方  分析优化
> 容器启动
 + 容器预建
 + 页面保活
> 资源加载
 + 网络配置：
 减少DNS解析(减少资源的域名个数)+DNS预解析(link标签增加dns-prefetch,pre-load 预加载，prefetch 空闲加载),
 开启http2(多路复用:本地在devserve中配置https和http2,线上的话需要再nginx配置文件中配置：listen 443 ssl http2)，智能调度
 + HTML加载
 1. 代码压缩: gzip
 2. 精简代码:webpack(tree shakeing,code split), 或者就是js-aot(静态编译)
    后编译：npm包并不需要在发布前编译，而是在应用编译打包时编译
    按需引入：
 3. 中台数据处理: egg/koa/express
 4. 服务端渲染: nuxt/next
 5. 流式传输: gpt数据传输方式,fetch:访问和操作http管道部分
 + 资源加载:
 1. 均衡加载
 2. 动态图片尺寸
 3. 动态polyfill: 全局的babel-polyfill会造成资源浪费，根据项目指定需要polyfill的特性，根据浏览器的特性动态引入polyfill
 4. 资源缓存
 5. 资源分级: css切分(node :Addy Osmani的Critical)
 6. 配置缓存: 1.网络资源的强缓存和协商缓存，通过Header头部字段(cache-control和expires)设置,2 数据缓存cookie(跟踪用户) session（服务器缓存） 3. 浏览器缓存 storage（本地持久化存储，会话级临时存储）和indexedDb（客户端数据库） 4. service worker： 浏览器后台脚本，拦截处理请求，进行离线缓存，动态缓存，高级缓存策略
 7. cdn优化:准备切换，速度探测
 8. 离线缓存：
 通过监听install生命周期，
 ```
 self.addEventListener('install')
 event.waitUntil(caches.open('my-cache').then(function(){
  return cache.addAll([
        '/index.html',
        '/styles.css',
        '/app.js',
        '/assets/icon.png'
      ]);
 }))
 ```
 动态缓存: 借助localstorage进行缓存
 9. 资源懒加载(路由懒加载，模块懒加载)
> 代码执行
+ 防抖节流，并发请求控制，webwork-计算线程开启，长任务拆解
> 数据获取
+ 请求合并，数据预处理，延迟请求，请求并行
> 绘制渲染
 + 虚拟列表
 + 延迟加载
 + 减少重排重绘
 + 图片预加载内存
 + 快照缓存
 + 服务端渲染:
 客户端侧都需要在内存中重新生成节点抽象、绑定事件并重建应用状态，这也就是常说的在客户端 “注水”;
 SSR 方案普遍将请求到的服务端数据序列化后作为 script 标签附带在 HTML 页面上;会导致内容和节点数据反复出现；
 + 基于流的服务端渲染及Javascript渐进式注水
 流式渲染允许你将 HTML 内容分块发送，浏览器可以在收到块后逐步渲染，即一边下载资源一边绘制应用；
 渐进性注水的应用程序的各个模块会相互独立、异步的进行自行注水；
 实现：客户端可以根据用户优先级，推迟低优先组件注水偶成，释放主线程响应用户操作；
 解决ssr-服务端渲染的dom发生变更后，需要再客户端立即重建
 + 选择性注水

### 广度回答->从业务场景触发
> 优化目标：(首屏加载速度指标)
> 优化范围：核心业务链路确定性能卡点
> 需求价值：技术价值(FMP,TTI 需要借助performance) 业务价值(跳失率，DAU，LT)
+ tti: 首次可交互时间，连续五秒内没有长任务或者两个get请求；
+ fid: fcp用于tti之间用户与页面交互响应的延迟
+ tbt: 阻塞总时间： 记录fcp和tti之间长任务的阻塞时间
+ fp: 首次绘制元素时间
+ fcp: 首次内容绘制时间
+ lcp: 视窗内最大内容绘制
+ cls: 页面上非预期的位移波动
> 技术方案：优化策略和执行策略
> 研发周期：前端-后端-运维，多环节接入
> 成本评估：方案的投入与产出
> 项目协作：主导方及协作方
###  性能排查
> 数据埋点上报
+ ajax 请求埋点(同域下)
+ 基于的可跨域的标签埋点上报
1. 推荐使用img:img标签加载并不需要挂载到页面上，基于js去new image()，设置其src之后就可以直接请求图片;
 但img加载后并不渲染，它需要等待Render Tree生成完后才和Render Tree一起渲染出来
2. script及link的缺陷:需要挂载到页面上，而反复操作dom会造成页面性能受影响，而且载入js/css资源还会阻塞页面渲染，影响用户体验

+ 基于Navigator.sendBeacon的埋点上报(通用)
1. navigator.sendBeacon()  方法可用于通过 HTTP POST 将少量数据 异步 传输到 Web 服务器
2. sendBeacon是异步的，不会影响当前页到下一个页面的跳转速度，且不受同域限制。这个方法还是异步发出请求，但是请求与当前页面脱离关联，作为浏览器的任务，因此可以保证会把数据发出去，不拖延卸载流程。
3. 尽量保证成功

+ 常见的埋点行为
1. 页面停留时间，默认设置开始时间，beforeEach拦截器后，获取当前时间并且计算停留时间，发布出去后，再次获取时间更新开始时间
2. 全部错误埋点捕获:
  
  (1) vue 全局捕获
  app.config.errorHandler = (err) => {})
  
  (2) JS异常与静态资源加载异常
  `

    window.addEventListener('error', (error) => { 
    if (error.message) { 
        navigator.sendBeacon(url, {error: error.message, text: 'js执行异常' })
    } else { 
        navigator.sendBeacon(url, {error: error.filename, text: '资源加载异常' })
    } 
}, true)

  `

  (3) 请求捕获异常

  axios.interceptors.response.use((response) => {},(error)=>{})


  (4) 全局用户行为记录
    `

     document.querySelector('#container').addEventListener('click', function (e) {
            if(e.target.classList.contains('jumpUrl')){
                console.log("点击jumpurl")
            }
        },false)
    
    `

    (5) 内容可见埋点(元素监听器)
    IntersectionObserver:监听元素的变化
    callback: 元素变化的回调函数
    options: 默认配置

    var observer = new IntersectionObserver(callback,options);
    observer.observe(target);


> 控制台的NetWork、Performance等工具
+ Performance
 1. 分析浏览器每时每刻在做什么，进行性能优化
 2. Performance介绍
    ![iamge](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/20/1699b7a2af999986~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)
    2.1 Screenshots 是用来查看在每个时间段界面的变化；
    
    2.2 Memory 存储调用栈的大小，在不同时间段的不同大小；

    2.3 通过Network这里，我们更直观的可以知道，资源是并行加载的

    2.4 Main:火焰图 , 这里是一个由下而上的事件执行图
    
    2.5 Summary（性能摘要）

            Loading ：加载时间
            Scripting ：js计算时间
            Rendering ：渲染时间
            Painting ：绘制时间
            Other ：其他时间
            Idle ：浏览器闲置时间

    2.6 为什么console.log不能带到线上，因为每一次的console.log 都会占用大量浏览器内存，且无法释放

>> 优化，根据performance 计算的首屏渲染时间不准确

+ 常见的首屏时间计算方式
1. 首屏时间: loadEventEnd - fetchStart/startTime 或者 domInteractive - fetchStart/startTime
2. 通过计算首屏区域内的所有图片加载时间，然后取其最大值
3. 利用 MutationObserver 接口，监听 document 对象的节点变化

> webpack-bundle-analyzer插件分析打包产物

### http相关
> gzip压缩
>> 什么是gzip
+ 浏览器请求url，并在请求头中设置属性accept-encoding：gzip。
+ 服务器接受gzip标识,返回压缩后的文件，没有则返回实际的文件
+ 浏览器接收到到服务器的响应，根据content-encoding: gzip 响应头使用gzip策略去解压压缩后的资源，通过content-type内容类型决定怎么编码读取该文件内容

>> webpack 开启gzip
+ 借助compression-webpack-plugin
+ 配置如下

    chainWebpack(config, {webpack}){
    config.plugin('compression-webpack-plugin').use(CompressionPlugin, [{
      algorithm: 'gzip',
      test:
      /\.(js|css|html|svg|gif|png|jpeg|txt)$/,
      filename: '[base].gz',
      threshold: 2048,
      deleteOriginalAssets: false,
    }])
  },

>> 补充:
+ content-type和content-encoding的区别
 1. content-type：内容类型，决定文件接收方以什么形式、什么编码读取这个文件(浏览器的扫描方式)
 2. content-encoding：设置文件内容的编码格式，传输前什么格式，传输后接收到要以什么格式解析，注重如何传输文件


> http缓存机制 强缓存、协商缓存  （http-cache 有详细的实战）
+ HTTP缓存常见的有两类：
> 强缓存：可以由这两个字段其中一个决定
+ expires
+ cache-control(优先级更高)
+ expires 秒数  cache-control 毫秒数
+ 第二次请求后，状态变为memory，这意味着，通过expires设置强缓存的时效是30s，这30s之内，资源都会走本地缓存，而不会重新请求

>协商缓存：与强缓存不同，协商缓存还是走的服务端，需要命中服务端资源，强缓存走本地，可以由这两对字段中的一对决定
+ Last-Modified，If-Modified-Since
+ Etag，If-None-Match(优先级更高)

>> Last-Modified，If-Modified-Since
+ 第一次请求资源时，服务端会把所请求的资源的最后一次修改时间当成响应头中Last-Modified的值发到浏览器并在浏览器存起来
+ 第二次请求资源时，浏览器会把刚刚存储的时间当成请求头中If-Modified-Since的值，传到服务端，服务端拿到这个时间跟所请求的资源的最后修改时间进行比对
+ 比对结果如果两个时间相同，则说明此资源没修改过，那就是命中缓存，那就返回304，如果不相同，则说明此资源修改过了，则没命中缓存，则返回修改过后的新资源

>> Etag，If-None-Match
+ 其实Etag，If-None-Match跟Last-Modified，If-Modified-Since大体一样，区别在于：
+ 后者是对比资源最后一次修改时间，来确定资源是否修改了
+ 前者是对比资源内容，来确定资源是否修改
+  将资源转化为hash值就可以进行比较了

### 图片
> 图片压缩
> 图片懒加载
> 雪碧图、使用字体图标、svg

### webpack（重点）
> Performance 资源控制
> 优化文件搜索
> 多进程打包
> 分包
> 代码压缩
> 模块联动

### 框架相关
> vue性能优化
> react性能优化
> 异步组件
> tree shaking
> 服务端渲染

### 代码实现
> 按需加载，逻辑后移，优先保证首屏内容渲染
> 复杂计算使用web worker
> 接口缓存、计算结果缓存
> 预加载，懒加载
+ 懒加载 作用于 图片流，文档流  通过对视窗的判断来控制展示的内容； 路由的懒加载  组件的懒加载（在使用组件的compoennt 引入需要的组件，而不是在一开始就使用）
+ 预加载 提前加载资源
> 骨架屏
+ 友好体验

> 虚拟滚动 
+ 属于懒加载的一种，通过视窗来控制数据的加载
+ 最新的Mdn 提供 IntersectionObserver， 通过监听指定标签的区域重合来判断数据的加载时间

> 接口进行防抖节流或者并发阀机制
![iamge](https://qiniu.gxxsh.cn/debounce.png)
> 并发接口控制
