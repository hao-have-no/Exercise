## 前端常见安全防范
> xss 攻击: 页面被注入恶意代码；
基于原生开发的页面，比如获取输入框输入之类的，可以在里面加入script脚本完成额外代码的注入
解决方案：escapeHTML(),进行转义 
Xss分为：
+ 存储型XSS
XSS 的恶意代码存在数据库里
+ 反射型XSS
反射型 XSS 漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。
+ DOM型
伪造弹窗广告这些，点击能够获取用户行为数据的恶意代码
+ 解决方案:
1. Content Security Policy
2. 避免内联开发，dom上直接执行具体参数的事件
3. 尽量使用框架来开发

> csrf 攻击:跨站请求伪造
模仿网页完成第三方网站请求
+ 解决方案：
1. 同源检测
Origin Header
Referer Header
2. Samesite Cookie
3. token、jwt
## docker
1. 容器特别像一个虚拟机，容器中运行着一个完整的操作系统；
2. 镜像是一个文件，它是用来创建容器的；
### docker 在线运行的脚本
+ 运行创建docker容器1
docker run -it -d --name myvue2 --privileged -p 8081:8080 -v  /Users/eric/my-repository/my-app-vue2:/app/vue node:10.16.2 /bin/bash -c "cd /app/vue && node -v && npm install && npm run serve"
+ 借助docker-compose,可以一次性启动多个项目

### docker的部署简要流程
dockerFile 配置文件--> Image 生成镜像文件--> container 根据镜像生成容器
> dockerFile
```
FROM nginx
COPY ./web-bladex-front /usr/share/nginx/html
EXPOSE 80
```
> 打包生成镜像
```
cd hello-docker/ # 进入刚刚的目录
docker image build ./ -t hello-docker:1.0.0 # 打包镜像
```
tips: 基于路径./（当前路径）打包一个镜像，镜像的名字是hello-docker，版本号是1.0.0。该命令会自动寻找Dockerfile来打包出一个镜像
> 根据镜像运行容器
```
// 根据1.0.0的镜像创建一个容器，指定容器的80端口绑定宿主机的2333端口上
docker container create -p 2333:80 hello-docker:1.0.0
// 返回容器的id，启动容器
docker container start xxx # xxx 为上一条命令运行得到的结果
```
## webpack 总结
> 热更新原理
+ Webpack编译期，为需要热更新的 entry 注入热更新代码(EventSource通信)
+ 页面首次打开后，服务端与客户端通过 EventSource 建立通信渠道，把下一次的 hash 返回前端
+ 客户端获取到hash，这个hash将作为下一次请求服务端 hot-update.js 和 hot-update.json的hash
+ 修改页面代码后，Webpack 监听到文件修改后，开始编译，编译完成后，发送 build 消息给客户端
+ 客户端获取到hash，成功后客户端构造hot-update.js script链接，然后插入主文档
+ hot-update.js 插入成功后，执行hotAPI 的 createRecord 和 reload方法，获取到 Vue 组件的 render方法，重新 render 组件， 继而实现 UI 无刷新更新。

> webpack Loader和Plugin的区别
1. Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 
2. Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，
在合适的时机通过 Webpack 提供的 API 改变输出结果。
3. Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。
每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。
4. Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例
参数都通过构造函数传入。

> webpack多入口打包，缓存问题
1. 多文件打包:entry中进行多文件的配置
2. 文件缓存:通过给打包的文件增加hash值,来进行相关的更新
3. 增加vender配置，来进行多入口文件打包,添加了一个CommonsChunkPlugin的插件，用于提取vendor
4. 添加了一个CommonsChunkPlugin的插件增加配置，增加names:names: ['vendor', 'manifest']
, manifest为修改的部分，vender的hash不改变
> webpack中loader和plugins配置问题
1. loader对打包流程的配置,因为webpack对于loader的调用是从右往左的
+ 配置bable-loader,profile来完成js的浏览器适配与优雅降级
+ style-loader(将css-loader转化的代码以标签的实行插入html中)和css-loader(处理js文件中引入的css模块（处理@import和url）)
+ loader和 exports-loader来处理amd模块的引用
2. plugins 提供第三方插件拓展webpack功能
+ 比如html-webpack-plugin:会将打包好的js文件自动引入到指定的html中去，并将html文件输出在指定位置
+ 多入口文件的话，可以在entry多入口文件打包的时候进行tmlPluginArray的实例化
3. resolve配置规定了webpack如何寻找各个依赖模块
4. 按需加载: import语法实现动态引用
5. 打包策略
+ 第三方库打包出vendor（基本不变）
+ 用两次以上的模块打包出common （变化较少）
+ 业务代码 （常变）
+ 对于分包方式，webpack 4 移除 CommonsChunkPlugin，取而代之的是optimization.splitChunks 
6. 优化loader配置
+ 配置exclude设置哪些目录下的文件不进行处理