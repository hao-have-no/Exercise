## JS事件执行机制-EventLoop

### 浏览器的进程模型
#### 浏览器是个多进程多线程的应用程序
+ 分为浏览器进程，网络进程，渲染进程
+ 为了避免互不影响，会进程会开辟很多线程去执行任务
+ 渲染进程开启后，会开启一个渲染主线程

> 渲染进程如何工作
>> 工作范围：解析HTML,解析CSS,计算样式，布局，处理图层，页面绘制，执行全局JS，执行事件处理函数，执行定时器回调任务......
>> 如何调度这些任务：



### EventLoop 事件执行机制
>补充:宏任务是一个栈按先入先执行的原则，微任务也是一个栈也是先入先执行。但是每个宏任务都对应会有一个微任务栈，宏任务在执行过程中会先执行同步代码再执行微任务栈。
一次事件循环就是一次宏任务+微任务执行完毕。

> 事件循环（消息循环）
+ 开始：渲染主线程会进行无线循环
+ 每一次循环都会判断消息队列里是否有任务，有的话就把第一个任务拿出来执行一下，没有的话就进行休眠
+ 其他线程可以往消息队列里面塞入任务，当主线程休眠时，也会唤醒主线程，进行任务的执行环节

> 什么是异步:
>> 无法立即执行的任务,保证渲染主线程永不阻塞
+ 1. setTimeout 定时任务
+ 2. xhr,fetch 网络通信任务
+ 3. addEventListener 事件执行监听任务
+ 4. 会将对应的任务交给对应的线程去计算

> chrome 最新定义，随着浏览器交互的复杂性，不再有宏队列这个说法，而是将不同的任务分为不同的队列，比如延时队列，交互队列，微任务队列，每个队列的任务执行级别不一样，微任务最高，延时最低

> 如何理解JS的异步
+ js是一门单线程语言，它运行在浏览器的渲染主线程中，而渲染主线程需要做很多工作，如果使用同步的方式
很大可能会导致进程阻塞，导致消息队列中的很多任务无法及时执行，导致页面无法及时更新，造成页面卡死现象；
所以浏览器采用异步的方式来避免，具体做法是当某些任务发生时（计时器，监听，网络请求等），渲染主线程会将
任务交给其他线程处理，自身任务执行完后去执行消息队列中由其他线程执行完产生的函数回调任务；这种机制能够
保证浏览器永不阻塞，单线程流畅运行；

> 阐述JS的事件循环
+ 事件循环又称为消息循环，是浏览器渲染主线程的工作方式；在Chrome中是这样实现的：开启一个永远不会结束的for循环，
每次循环从消息队列中取出第一个任务执行，而且其他线程只需在合适的时间将任务加到队列末尾即可；
之前消息队列成为宏任务和微任务队列，现在的浏览器环境复杂，将进一步优化这块；
同类型的任务必须在一个队列中，不同的任务属于不同的队列，队列有执行的优先级，一次事件循环，由浏览器自行选择任务队列，
单浏览器中势必会有一个微任务队列且为最高优先级；

> 补充
+ 单线程是异步产生的原因
+ 事件循环是异步的实现方式


### 浏览器渲染原理
+ 将HTML 通过处理 渲染为页面上的每一个像素点
+ 渲染函数:render: 得到像素点->移交gpu->完成绘制
+ 网络：拿html 渲染：处理html
+ 网络进程--》网络线程--》 拿到html --> 生成渲染任务 --> 消息队列--> 渲染主线程--> 渲染
+ 整个渲染流程大致分为:HTML解析，样式计算，布局，分层，绘制，分块，光栅化、位图绘画

> 浏览器是如何渲染页面的（参考面试记录-2021-2021-05-06）
>>网络进程收到HTML文档后，产生渲染任务，传递给渲染主线程的消息队列，在事件循环机制下，渲染主线程取出消息队列的渲染任务，开启渲染流程；
>> 1. 解析HTML-Parse HTML-DOM树和cssDOM树
+ HTML在解析过程遇到CSS怎么办？为提升解析效率，浏览器会提前开启预解析器下载和解析css；解析器解析css完成后会生成任务，渲染主线程会拿到任务并且生成cssDOm; ---》css不会阻塞页面加载的
+ 
+ cssDom(styleSheetList)树![alt cssDom](https://picx.zhimg.com/80/v2-33a576f9c3d41dc7a4d8321f6a219677_720w.webp?source=1def8aca)

>> 2. 样式计算 分析DOM和cssDom树的关联关系-recalculate style--》 computed style(计算后的最终样式)
+ Css属性值计算(层叠，继承)

+ 视觉格式化模型(盒模型，浮动，定位)

>> 3. 布局layout tree
+ layout tree != css dom ,因为某些元素是隐藏的，布局得到的是具有几何属性的元素集合
+ 行级元素/块级元素没再有这种说法(html 只是提供具有这种特性的语义化标签s)，内容必须存在行盒中（css说法）,
行盒和块盒不能相邻
+ 布局阶段会遍历dom树的每个节点，进行几何信息计算（高度，宽度等）,dom树中虽然没有伪元素信息，但是在布局阶段，会出现在布局树中

>> 4. 分层
+ 与堆叠上下文有关（z-index,positions,opactive,tansform），通过will-change属性更大程度上影响分层结果
+ 主线程会使用一套复杂的策略对布局树进行分层，在页面发生改变时，只需要对对应的层进行更新就好

>> 5. 绘制-paint
+ 对每一层，生成绘制页面的指令
+ 至此渲染主线程的工作结束，剩下的流程交由合成线程处理


>> 合成线程
+ 1. 分块 tiling 将每一层分为分为多个区域，例如（只画视窗内部的东西）
+ 2. 分块后进入光栅化，将信息交给gpu进程，光栅化是为了生成位图（执行绘制指令）
+ 3. 光栅化后进行绘画阶段，拿到位图后，会生成一个个的指引(quad)信息，指引会标注每个位图在屏幕的位置，是否需要旋转，缩放等；transform（效率高的原因）
+ 4. 最后将所有的指引信息提供给gpu进程，gpu进程会调用gpu硬件，完成最终的屏幕成像；gpu进程是浏览器进程的一种；

>> 额外补充1：为什么不能直接调用gpu硬件，而是要通过gpu线程
+ 渲染进程属于沙盒环境，是独立，保证浏览器的安全；不会因为网络直接攻击电脑操作系统

>> 额外补充2：reflow 回流
+ 某些操作导致了layout tree的重新计算（重新定义宽，高，字体大小等，dom的增删改）
+ 浏览器优化在多次操作后，统一进行一次再计算，这时reflow 是异步的;但如果在操作后立马读取页面属性信息，reflow就是同步任务；设置不会relfow，读取会立马reflow

>> 额外补充3：repaint 重绘
+ 某些操作导致局部的dom进行重绘（颜色，显隐性）
