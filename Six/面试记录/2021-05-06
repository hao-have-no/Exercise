### BFC
> 块级格式化上下文 
> 一个独立的渲染区域，只有Block-level box参与， 
  它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干

> 怎么生成的:
+ 根元素  float  overflow不为visible　display的值为inline-block、table-cell、table-caption　
+ position的值为absolute或fixed

> 约束规则
+ 内部的Box会在垂直方向上一个接一个的放置
+ 垂直方向上的距离由margin决定(div margin坍塌)
+ 元素的左外边距与包含块的左边界相接触（从左向右），即使浮动元素也是如此(两栏布局)。
+ BFC的区域不会与float的元素区域重叠 (消除浮动)
+ 计算BFC的高度时，浮动子元素也参与计算 (消除浮动)
+ BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面元素，反之亦然

+ Block元素会扩展到与父元素同宽，所以block元素会垂直排列
+ 垂直方向上的两个相邻DIV的margin会重叠，而水平方向不会
+ 浮动元素会尽量接近往左上方（或右上方）
+ 为父元素设置overflow：hidden或浮动父元素，则会包含浮动元素


### HTTP1与HTTP2,HTTPS的关系
> 前置:URI是什么
+ 统一资源标识符,区别不同的资源
+ 实际上URI包含了URN和URL两个部分，由于 URL 过于普及，就默认将 URI 视为 URL 了
+ https://(scheme)  (user:passwd@)www.baidu.com( host:port)/s(path)?wd=HTTP&rsv_spt=1(query)(fragment表示)
+ scheme 表示协议名，比如http, https, file等等。后面必须和://连在一起。
+ user:passwd@ 表示登录主机时的用户信息，不过很不安全，不推荐使用，也不常用。
+ host:port表示主机名和端口。
+ path表示请求路径，标记资源所在位置
+ query表示查询参数，为key=val这种形式，多个键值对之间用&隔开。
+ fragment表示 URI 所定位的资源内的一个锚点，浏览器可以根据这个锚点跳转到对应的位置。 

+ URI 只能使用ASCII, ASCII 之外的字符是不支持显示的，而且还有一部分符号是界定符，如果不加以处理就会导致解析出错。
+ URI 引入了编码机制，将所有非 ASCII 码字符和界定符转为十六进制字节值，然后在前面加个%


> Http1
+ 是一种无状态、无连接的应用层协议,规定浏览器和服务器保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接
+ 服务器处理完成后立即断开TCP连接（无连接），服务器不跟踪每个客户端也不记录过去的请求（无状态）
+ 可以借助cookie/session机制来做身份认证和状态记录
+ 缺点1.无连接的状态不能复用连接，每次都需要进行tcp连接和断开,利用率很低，交互性不好
+ 缺点2.请求队列堵塞，http1.0规定下一个请求必须在上个请求响应到达才能发送；

> Http1.1
+ 设置长连接,HTTP1.1增加了一个Connection字段，通过设置Keep-Alive可以保持HTTP连接不断开，
避免了每次客户端与服务器请求都要重复建立释放建立TCP连接，
提高了网络的利用率。如果客户端想关闭HTTP连接，可以在请求头中携带Connection: false来告知服务器关闭请求

+ 请求管道化（pipelining）keep-alive 支持并行加载各个请求(eg:img)，但是这个并行不是真正意义上的并行
--> 服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。
--> 也就是说，HTTP管道化可以让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列）。
--> 通常浏览器的并行请求资源是因为:允许我们打开多个TCP的会话,是不同的TCP连接上的HTTP请求和响应。
--> 这也就是我们所熟悉的浏览器对同域下并行加载6~8个资源的限制。而这，才是真正的并行

+ HTTP1.1还加入了缓存处理（强缓存和协商缓存)
--> 如cache-control，支持断点传输，以及增加了Host字段（使得一个服务器能够用来创建多个Web站点）

+ 增加Host字段、支持断点传输等

> Http 2
+ 在应用层和传输层之间增加一个二进制分帧层，突破了HTTP1.1的性能限制、改进传输性能。
--> 二进制分帧层：简单来说，HTTP2.0只是把原来HTTP1.x的header和body部分用frame重新封装了一层而已
--> 将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，
    其中HTTP1.x的首部信息会被封装到Headers帧，而我们的request body则封装到Data帧里面。

+ 多路复用(连接共享):
--> 流（stream）：已建立连接上的双向字节流。
--> 消息：与逻辑消息对应的完整的一系列数据帧。
--> 帧（frame）：HTTP2.0通信的最小单位，每个帧包含帧头部，至少也会标识出当前帧所属的流（stream id）。
--> HTTP2.0通信都在一个TCP连接上完成，这个连接可以承载任意数量的双向数据流
--> 每个数据流以消息的形式发送，而消息由一或多个帧组成。这些帧可以乱序发送，然后再根据每个帧头部的流标识符（stream id）重新组装
--> 多路复用（连接共享）可能会导致关键请求被阻塞。
--> HTTP2.0里每个数据流都可以设置优先级和依赖，优先级高的数据流会被服务器优先处理和返回给客户端，数据流还可以依赖其他的子数据流

+ 头部压缩
--> HTTP1.x中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷
--> HTTP2.0使用encoder来减少需要传输的header大小，
--> 通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。
--> 高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。

> Https:
--> HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL(Secure Socket Layer)和 TLS(Transport Layer Security)协议代替而已
--> HTTP 直接和 TCP 通信。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了
--> HTTPS 协议的主要功能基本都依赖于 TLS/SSL 协议，TLS/SSL 的功能实现主要依赖于三类基本算法：散列函数、对称加密和非对称加密，
--> 其利用非对称加密实现身份认证和密钥协商，客户端共享公钥，服务器掌握私钥,进行身份验证
--> 对称加密算法采用协商的密钥对数据加密,服务端和及客户端共享公钥，不同客户端秘钥不同，服务端维护多个秘钥，进行信息加密
--> 基于散列函数验证信息的完整性。

+ 交互流程
1. 客户端发起HTTPS请求(客户端会发送一个密文族给服务端，密文族是浏览器所支持的加密算法的清单)
2. 服务端配置(采用HTTPS协议的服务器必须要有一套数字证书,自己的会提示，信任公司不提示，这套证书其实就是一对公钥和私钥)
3. 传送证书(就是公钥，只是包含了很多信息，如证书的颁发机构、过期时间等等。)
4. 客户端解析证书(由客户端的TLS来完成的,先验证公钥是否有用,如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。)
5. 传送加密信息(传送的是用证书加密后的随机值，让服务端得到这个随机值，然后客户端和服务端的通信就可以通过这个随机值来进行加密和解密了)
6. 服务端解密信息(服务端用私钥解密后，得到了客户端传过来的随机值，至此一个非对称加密的过程结束，
--> TLS利用非对称加密实现了身份认证和密钥协商。然后把内容通过该值进行对称加密)
7. 传输加密后的信息(服务端用随机值加密后的信息，可以在客户端被还原)
8. 客户端解密信息(用之前生成的随机值解密服务端传送过来的信息,对称加密的过程结束)

> HTTPS加密算法有哪些
1. 对称加密有AES + CHACHA20,分组模式以前有 CBC、CTR，TLS1.3 中只剩下 GCM 非对称加密 RSA、ECDHE

> 怎么握手的呢？
1. 传统 RSA
2. TLS1.2
3. TLS1.3(Session ID、Session Ticket 以及 PSK)

> HTTP 和 HTTPS 的共同点和区别
1. https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用。
2. http 是超文本传输协议，信息是明文传输， https 则是具有安全性的ssl加密传输协议。
3. http 和 https 使用的是完全不同的连接方式
4. http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 http 协议安全

> 跨域及解决方案
1. jsonp:在对应的域名下动态创建script脚本，再请求一个带参网址实现跨域通信，传入回调函数并且执行
2. document.domain + iframe跨域-->此方案仅限主域相同，
子域不同的跨域应用场景(实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。)
3. location.hash + iframe跨域
4. window.name + iframe跨域 
5. postMessage跨域
6. 跨域资源共享（CORS）-->服务端设置Access-Control-Allow-Origin即可，若要带cookie请求：前后端都需要设置。
7. nginx代理跨域,配置解决iconfont跨域,nginx反向代理接口跨域
8. Nodejs中间件代理跨域

> Http缓存:浏览器缓存主要分为强缓存（也称本地缓存）和协商缓存（也称弱缓存）。
+ 强缓存是利用 http 头中的 Expires 和 Cache-Control 两个字段来控制的，用来表示资源的缓存时间
--> 不会向服务器发送请求，直接从缓存中读取资源
--> 有缓存命中和缓存未命中状态(再次请求，直接存入缓存体系)

+ 协商缓存就是由服务器来确定缓存资源是否可用
--> 涉及到两组 header 字段： Etag 和 If-None-Match、 Last-Modified和 If-Modified-Since。

> Accept 系列字段: 分为四个部分-->数据格式、压缩方式、支持语言和字符集
+ HTTP 灵活的特性，它支持非常多的数据格式,客户端怎么知道它的格式
--> MIME标准,HTTP 从MIME type取了一部分来标记报文 body 部分的数据类型，这些类型体现在Content-Type这个字段
--> text： text/html... image: image/gif  audio/video: audio/mpeg, video/mp4 application: application/json, application/javascript

+ 压缩方式:数据都是会进行编码压缩的
--> 采取什么样的压缩方式体现在了发送方的Content-Encoding字段上,接收什么样的压缩方式体现在了接受方的Accept-Encoding字段+

+ 支持语言:Content-Language字段

+ 字符集: 收端对应为Accept-Charset，指定可以接受的字符集，而在发送端并没有对应的Content-Charset, 
--> 而是直接放在了Content-Type中，以charset属性指定

> 对于不定长的数据怎么传输
+ 定长包体(带上 Content-Length, 来指明包体的长度)
+ 不定长包体(Transfer-Encoding: chunked,分块传输数据)


### URL地址栏具体发生了什么
> DNS解析
+ 首先在本地的域名服务器中查找，没找到去根域名服务器查找，没有再去com顶级域名服务器查找，
--> 如此的类推下去，直到找到IP地址，然后把它记录在本地，供下次使用。

+ DNS优化:
1. DNS缓存:浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存
2. DNS负载均衡:拥有很多服务器，根据特定的规则，返回IP给用户

> 建立TCP连接:三次握手，四次挥手 
1. 序号(序列号seq)：是TCP可靠传输的关键部分,是该报文段发送的数据组的第一个字节的序号;在TCP传送的流中，每一个字节都有一个序号。
2. 确认号：即ACK,指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到,
> 确认号只有当ACK标志为1时才有效。比如建立连接时，SYN报文的ACK标志位为0。
3. 首部长度/数据偏移：占4位，它指出TCP报文的数据距离TCP报文段的起始处有多远
4. 控制位：URG ACK PSH RST SYN FIN，共6个，每一个标志位表示一个控制功能。
--> 紧急URG：当URG=1，表明紧急指针字段有效。告诉系统此报文段中有紧急数据
--> 确认ACK：仅当ACK=1时，确认号字段才有效。TCP规定，在连接建立后所有报文的传输都必须把ACK置1。
--> 推送PSH：当两个应用进程进行交互式通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应，这时候就将PSH=1
--> 复位RST：当RST=1，表明TCP连接中出现严重差错，必须释放连接，然后再重新建立连接。
--> 同步SYN：在连接建立时用来同步序号。当SYN=1，ACK=0，表明是连接请求报文，若同意连接，则响应报文中应该使SYN=1，ACK=1。
--> 终止FIN：用来释放连接。当FIN=1，表明此报文的发送方的数据已经发送完毕，并且要求释放。
5. 三次握手的过程(注意的是： （A）不要将确认序号Ack与标志位中的ACK搞混了。 （B）确认方Ack=发起方Req+1，两端配对。)
--> 客户端发送syn包(Seq=x)到服务器，并进入SYN_SEND状态，等待服务器确认 SYN =1,SEQ(序号) = X;
--> 服务端接受syn包,确认客户的SYN = ack + 1;同时自己发送syn(Seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； SYN = 1,ACK = X + 1,SEQ = Y;
--> 客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=y+1),客户端和服务器进入ESTABLISHED状态，完成三次握手 ACK = Y+1,SEQ = Z;

6. 为什么客户端最后还要等待2MSL
--> 保证客户端发送的最后一个ACK报文能够到达服务器
--> 防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中

> 发送HTTP请求

> 服务器处理请求并返回HTTP报文
1. 对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用

> 连接结束
1.　为了避免服务器与客户端双方的资源占用和损耗，当双方没有请求或响应传递时，任意一方都可以发起关闭请求

> 浏览器解析渲染页面(GUI线程(页面渲染)和javascript解析器(js解析)是互斥的)
------>　粗略说明
1. 解析HTML形成DOM树
->(字节 -> 字符 -> 令牌(浏览器会根据HTML规范来将字符串转换成各种令牌) 
-> 节点对象(每个令牌都会被转换成定义其属性和规则的对象) -> 对象模型)

2. 解析CSS形成CSSOM树(都被分析成一个StyleSheet对象，每个对象都包含CSS规则)'

3. 合并DOM树和CSSOM树形成渲染树
--> 浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应
--> 渲染树布局从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，
布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小
--> 在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。

4. 浏览器开始渲染并绘制页面 这个过程涉及两个比较重要的概念回流和重绘（比较消耗浏览器性能）
--> DOM结点都是以盒模型形式存在，需要浏览器去计算位置和宽度等，这个过程就是回流。
（浏览器窗口大小发生改变，元素字体大小变化，激活CSS伪类（例如：:hover））
--> 等到页面的宽高，大小，颜色等属性确定下来后，浏览器开始绘制内容，这个过程叫做重绘。
（避免使用table布局，避免设置多层内联样式。）（避免频繁操作样式，避免频繁操作DOM）

5. 解析js脚本，会与解析html和css的流程冲突;
--> JS的解析是由浏览器的JS引擎完成的
--> 所有的同步任务放在主线程上执行，形成执行栈
--> 所有异步任务放在任务队列中

6. 其他补充
--> 如何加快页面渲染(资源预加载:Pre-fetching是一种提示浏览器预先加载用户之后可能会使用到的资源的方法,http缓存等)

7. 渲染进程补充
-> HTML词法分析和语法分析（AST解析说明），CSS解析，
-> 布局阶段:生成layoutTree，进行布局计算
-> 合成图层、生成绘制列表，合成线程调用光栅化线程池，
--> 合成图层(生成LayerTree):
   (1) RenderLayers 渲染层，这是负责对应 DOM 子树
   (2) GraphicsLayers 图形层，这是负责对应 RenderLayers子树。
   (3) DOM 树中每个节点都会对应一个 LayoutObject，
   当他们的 LayoutObject 处于相同的坐标空间时，就会形成一个 RenderLayers ，也就是渲染层。
   (4) RenderLayers 来保证页面元素以正确的顺序合成，这时候就会出现层合成（composite），从而正确处理透明元素和重叠元素的显示
   (5) renderLayer成为合成层后，会有自己的绘图上下文，并且会开启硬件加速，有利于性能提升
   (5-1) 合成层的位图，会交由 GPU 合成，比 CPU 处理要快
   (5-2) 当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层
   (5-3) 对于 transform 和 opacity 效果，不会触发 layout 和 paint
--> 生成绘制列表
   (1)渲染引擎将图层分成很小的若干个绘制命令
   (2)指令按顺序形成绘制列表，将列表提交到合成线程
--> 合成线程调用光栅化线程池
   (1) 栅格化:将图块转化为位图
   (2) 合成线程将图层转化为图块，并在光栅化线程池进行栅格化，生成位图
-> 生成位图后浏览器进程间通信过程，显卡缓存与显示器的关系
   (1)图块完全变成位图后，合成线程执行绘制图块命令(DrawQuad),将命令提交给浏览器进程
--> 生成位图后浏览器进程间通信过程
   (1) 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上

8. 优化渲染性能
--> 优化JS的执行效率
   (1)动画实现使用requestAnimationFrame
   (2)长耗时的JS代码放到Web Workers中执行
   (3)拆分操作DOM元素的任务，分别在多个frame完成--> 把任务分为若干个小任务，每个任务都放到 requestAnimationFrame中回调执行
   (4)使用Chrome DevTools的Timeline来分析JavaScript的性能
--> 降低样式计算的范围和复杂度
   (1) 减少需要执行样式计算的元素个数
--> 避免大规模、复杂的布局
   (1)尽可能避免触发布局,比如top,left...
   (2)使用flexbox替代老的布局模型(相对/绝对/浮动)
   (3)避免强制同步布局事件的发生(JS脚本是在layout之前执行,可以强制浏览器在执行JS脚本之前先执行布局过程)
--> 简化绘制的复杂度、减少绘制区域
   (1) 使用transform来实现移动效果的元素将会被正常绘制，同时不会触发其他元素的绘制
--> 优先使用渲染层合并属性、控制层数量
   (1) 使用transform/opacity实现动画效果
--> 对用户输入事件的处理函数去抖动

