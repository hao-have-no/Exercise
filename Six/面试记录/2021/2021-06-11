### 预加载－－蚂蚁金服·数据体验技术团队
> preload的使用
+ 提供了一种声明式的命令，让浏览器提前加载指定资源(加载后并不执行),等待合适的时机再执行
+ 将加载和执行分离开，不阻塞渲染和 document 的 onload 事件
+ eg: 提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出
 
//使用 link 标签静态标记需要预加载的资源
<link rel="preload" href="/path/to/style.css" as="style">

实际应用:cdn加载资源文件
+ 设置为提前加载，以及有一些模块虽然是按需异步加载，
但在某些场景下知道其必定会加载的，则可以设置 preload 进行预加载

---->> preload与prefetch的区别(preload 的资源加载顺序将被提前)
+ preload  是告诉浏览器页面必定需要的资源，浏览器一定会加载这些资源；
+ prefetch 是告诉浏览器页面可能需要的资源，浏览器不一定会加载这些资源。

---->> prefetch 是预测会加载指定资源
页面加载后会初始化首屏组件，当用户滚动页面时，会拉取第二屏的组件，若能预测用户行为，则可以 prefetch 下一屏的组件

---->> 避免滥用 preload(使用的话chrome会有ｗａｒｎ提示)
若不确定资源是必定会加载的，则不要错误使用 preload，以免本末倒置，给页面带来更沉重的负担。
在 PC 中使用 preload 来刷新资源的缓存，但在移动端则需要特别慎重，因为可能会浪费用户的带宽。

--->> 避免混用 preload 和 prefetch, 不会复用资源，而是会重复加载。
--->> 避免错用 preload 加载跨域资源
+ 对已知必加载的 font 文件进行预加载，除了有性能提升外，更有体验优化的效果。
+ 对跨域的文件进行 preload 的时候，我们必须加上 crossorigin 属性

> 浏览器的加载优先级
+ html 主要资源，其优先级是最高的;css 样式资源，其优先级也是最高的
+ script 脚本资源，优先级不一;
+ 样式引入:在 preload 的请求中，缺少了一个 origin 的请求头字段，表示这个请求是匿名的请求。
个请求能共用缓存的话，目前的解法是给 preload 加上 crossorigin 属性，
这样请求头会带上 origin, 且与样式引入的请求同源，从而做到命中缓存

> 动态引入



>http:多个状态值表示
eg:
--> Accept:告诉WEB服务器自己接受什么介质类型
--> Cache-Control: 指定请求和响应遵循的缓存机制
缓存指令包括

no-cache:指示请求或响应消息不能缓存，实际上是可以存储在本地缓存区中的
与原始服务器进行新鲜度验证之前，缓存不能将其提供给客户端使用。　
no-store:缓存应该尽快从存储器中删除文档的所有痕迹，因为其中可能会包含敏感信息

max-age: 缓存无法返回缓存时间长于max-age规定秒的文档，若不超规定秒浏览器将不会发送对应的请求到服务器，
数据由缓存直接返回；超过这一时间段才进一步由服务器决定是返回新数据还是仍由缓存提供

max-stale:指示客户端可以接收过期响应消息

Public：指示响应可被任何缓存区缓存，可以用缓存内容回应任何用户。

--> Connection:表示是否需要持久连接
告诉WEB服务器或者代理服务器，在完成本次请求的响应后，断开连接，不要等待本次连接的后续请求了。
--->
Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），
它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间
如果浏览器请求保持连接，则该头部表明希望 WEB 服务器保持连接多长时间（秒）
--> 
Keepalive：告诉WEB服务器或者代理服务器，在完成本次请求的响应后，保持连接，等待本次连接的后续请求。
