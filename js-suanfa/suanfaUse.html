<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>sufa</title>
</head>
<body>
</body>
<script>
    //回文
    //const sucai="qqqwwweeewwwqqq";
    // function checkPalindom(str){
    //     return str == str.split('').reverse().join('');
    // }
    // const real=checkPalindom(sucai);
    // console.log(real);

    //去掉重复值(1,indexof确认。2：object的key值确认)
    // let unique=[1,2,13,24,25,2,11,14,1,2,11];
    //
    // getUnique=(str)=>{
    //     let data=[];
    //     let obj={}
    //     for (let i=0,l=str.length;i<l;i++){
    //         // if(data.indexOf(str[i]) == -1){
    //         //     data.push(str[i]);
    //         // }
    //         if(!obj[str[i]]){
    //             obj[str[i]]=true;
    //             data.push(str[i]);
    //         }
    //     }
    //     return data;
    // }
    //     const real=getUnique(unique);
    //     console.log(real);

    //计算重复最多的元素和次数
    // function getmaxstr(str){
    //     if(str.length == 0){
    //         return str;
    //     }
    //     var newarr=[];
    //     for(let i=0,l=str.length;i<l;i++){
    //         if(!newarr[str.charAt(i)]){
    //             newarr[str.charAt(i)] = 1;
    //         }else{
    //             newarr[str.charAt(i)] +=1;
    //         }
    //     }
    //     console.log(newarr);
    //
    //     var maxkey='';
    //     var maxValue=1;
    //     for(var k in newarr){
    //         if (newarr[k]>maxValue){
    //             maxValue=newarr[k];
    //             maxkey=k;
    //         }
    //     }
    //     console.log(maxkey,maxValue);
    //     return (maxkey+"*"+maxValue);
    // }
    //  var strs="assfdsghjsddggedfsvgh";
    // // var strr=["1","a","s","a","d","f","s","7","fg"];
    // console.log(getmaxstr(strs));

    //快排
    // function quickSort(arr){
    //     if(arr.length<1){
    //         return arr;
    //     }
    //
    //     let leftArr=[];
    //     let rightArr=[];
    //     let q = arr[0];
    //     for(let i = 1,l=arr.length; i<l; i++){
    //         if(arr[i]>q){
    //             rightArr.push(arr[i])
    //         }else{
    //             leftArr.push(arr[i]);
    //         }
    //     }
    //     console.log(leftArr,[q],rightArr)
    //    return [].concat(quickSort(leftArr),[q],quickSort(rightArr));
    //     //只拼接了[q]
    // }
    // var sort=[8,3,5,2,10,1,12,16,4,7,15];
    // console.log(quickSort(sort));

    //判断最大差值
 //    const arr=[9,3,1,4,5,8,12];
 //
 //    function findMax(arr){
 //        var minValue=arr[0];
 //        var maxVal=0;
 //
 //        for(let i in arr){
 //            const realMin=arr[i]
 //            minValue=Math.min(minValue,realMin);
 //            const realMax=realMin-minValue;
 //            maxVal=Math.max(realMax,maxVal);
 //        }
 //     return maxVal;
 //    }
 // console.log(findMax(arr))

    //最大公约数
    // function greatestCommonDivisor(a,b){
    //     var num=0;
    //     while(b!=0){
    //         num=a%b;
    //         a=b;
    //         b=num;
    //     }
    //     return a;
    // }
    //
    // let s=greatestCommonDivisor(8,12)
    // console.log(s);

    // function treeObj(obj) {
        // obj.map(item => {
        //     if (item.parent !== null) {
        //         obj.map(o => {
        //             if (item.parent === o.id) {
        //                 if (!o.child) {
        //                     o.child = [];
        //                 }
        //                 o.child.push(item);
        //                 o.child = o.child;
        //             }
        //         });
        //     }
        // });
        // return obj.filter(item => item.parent === null)[0]

    //根据对应关系，生成树
    //     obj.map(item=>{
    //         if(item.parent !== null){
    //             obj.map(o =>{
    //                 if(item.parent === o.id){
    //                     if(!o.child){
    //                         o.child=[];
    //                     }
    //                     o.child.push(item);
    //                     o.child=o.child;
    //                 }
    //             });
    //         }
    //     });
    //     console.log(obj);
    //      return obj.filter(item =>item.parent === null)[0];
    // }
    //
    // var obj = [
    //     { id:5, parent:2},
    //     { id:4, parent:3 },
    //     { id:3, parent:1 },
    //     { id:1, parent:null },
    //     { id:2, parent:1 },
    // ]
    //
    // console.log(treeObj(obj));

    function fun(n, o) {
        console.log(o);
        return {
            fun: function(m) {
                return fun(m, n);
            }
        }
    }//第一次执行后生成fun回到函数，而之前作为回调函数的变量被保存
    //闭包能够将变量保存到内存中
    // fun(0) //显示undefined，n=0,生成fun回调函数
    // fun(0).fun(1)//fun(m=1)==>return fun(m=1,n=0)=>n=m=1,o=0==>生成fun（m）,此时n=1;



</script>
</html>
